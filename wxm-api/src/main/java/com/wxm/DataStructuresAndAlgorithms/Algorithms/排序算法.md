## 排序算法：

1. **冒泡排序（Bubble Sort）**
冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

步骤：

比较相邻的元素。如果第一个比第二个大，就交换它们两个；
对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；
针对所有的元素重复以上的步骤，除了最后一个；
重复步骤1~3，直到排序完成。


2. **选择排序（Selection Sort）**
选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，将其与待排序的数据序列的最前面（或最后面）的元素进行交换，然后缩小待排序数据序列的范围，直到全部待排序的数据元素都排好序为止。

步骤：

初始化一个变量，用来记录当前遍历到的最小元素的索引，初始值为第一个元素的索引；
遍历待排序的数据序列，从第二个元素开始；
对于每个遍历到的元素，如果它小于当前记录的最小元素，就更新最小元素的值和最小元素的索引；
遍历结束后，将记录的最小元素与待排序数据序列的第一个元素交换，然后缩小待排序数据序列的范围，直到全部待排序的数据元素都排好序为止。

3.**插入排序（Insertion Sort）**
插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

步骤：

初始化一个变量，用来记录当前遍历到的已排序元素的索引，初始值为1；
遍历待排序的数据序列，从第二个元素开始；
对于每个遍历到的元素，如果它小于已排序数据序列中当前遍历到的元素，就交换它们两个的位置，并将已排序元素的索引向前移动一位；
遍历结束后，已排序数据序列就排好序了。

4. **快速排序（Quick Sort）**
快速排序（Quick Sort）是一种高效的排序算法。它的工作原理是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

步骤：

选择一个基准元素（pivot），通常选择第一个或最后一个元素；
创建一个空列表（stack）和一个已排序列表（sorted），将基准元素放入已排序列表；
遍历待排序的数据序列，对于每个遍历到的元素：
如果它小于基准元素，就把它放入栈中；
如果它大于等于基准元素，就从栈中弹出所有元素，直到栈为空，然后将这个元素放入已排序列表；
遍历结束后，将基准元素放入已排序列表，然后将已排序列表中的元素依次放入数据序列中，最后得到一个有序序列。


5.**归并排序（Merge Sort）**
归并排序（Merge Sort）是一种高效的排序算法。它的工作原理是将待排序的多个序列依次合并，形成一个有序序列。

步骤：

将待排序的多个序列依次合并，形成一个有序序列。
遍历待排序的数据序列，对于每个遍历到的元素：
如果它小于基准元素，就把它放入栈中；
如果它大于等于基准元素，就从栈中弹出所有元素，直到栈为空，然后将这个元素放入已排序列表；
遍历结束后，将基准元素放入已排序列表，然后将已排序列表中的元素依次放入数据序列中，最后得到一个有序序列。