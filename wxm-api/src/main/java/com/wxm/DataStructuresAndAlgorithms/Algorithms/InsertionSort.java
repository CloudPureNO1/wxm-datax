package com.wxm.DataStructuresAndAlgorithms.Algorithms;

/**
 *
 * 插入排序（Insertion Sort）是一种简单直观的比较型排序算法。它的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录增1的有序表。在实现上，算法通过在已排序列表中从后向前扫描，找到当前项的正确位置并将其插入。
 *
 * 以下是插入排序的基本步骤：
 *
 * 从数组的第二个元素开始，将这个元素记为key。
 * 将key与它前面的元素进行比较。
 * 如果前面的元素大于key，则将前面的元素向后移动一位。
 * 重复步骤3，直到找到小于等于key的元素或到达数组的起始位置。
 * 在适当的位置插入key。
 * 对数组中的每一个元素重复上述过程，直到整个数组排序完成。
 * 插入排序的时间复杂度为O(n^2)，其中n是数组长度。尽管对于大数据集来说效率不高，但它在小数据集或者部分已排序的数据集中表现良好，并且是一种稳定的排序算法，即相等的元素不会改变它们原来的顺序。此外，插入排序是一种原地排序算法，意味着它不需要额外的存储空间。
 *
 * @author 王森明-wangsm
 * @version 1.0.0
 * @date 2024-07-23 16:54:57
 */
public class InsertionSort {

    /**
     * 这个方法使用插入排序算法来对一个数组进行排序。
     * 我理解你的困惑。在插入排序中，我们确实从已排序部分的末尾（即新元素的前一个位置）向头部检查并比较。让我澄清一下这个过程：
     *
     * 1. 假设数组的第一个元素已经是排序好的。
     * 2. 对于数组中的每个后续元素（从第二个元素开始，即i = 1），我们将这个元素作为“键”（key），并试图将其插入到已排序部分的适当位置。
     * 3. 为了找到这个位置，我们从当前元素的前一个位置（j = i - 1）开始，逆向遍历已排序的部分，比较key和已排序部分的每个元素。
     * 4. 如果key小于当前正在比较的元素，我们就将这个比较的元素向后移动一位，给key腾出空间。
     * 5.我们继续逆向遍历，直到找到一个比key小的元素或者到达了已排序部分的开头（j >= 0的条件不再满足）。
     * 6. 这时，key就被放置在正确的位置上，即arr[j+1]。
     * 所以，虽然我们是在从后向前检查已排序部分，但这个过程是为了将一个新的元素插入到已排序序列的正确位置，而不是从头开始对整个数组进行排序。每次迭代都只处理一个新元素，并将其插入到合适的地方。
     *
     *
     * 插入排序时间复杂度：
     * 插入排序（Insertion Sort）的时间复杂度分析如下：
     *
     * 最佳情况
     * 在最佳情况下，输入数组已经是排序好的。此时，插入排序只需遍历数组，但不需要进行任何元素间的比较或交换，因为每个元素都已经被认为是在其正确的位置上。因此，在这种情况下，插入排序的时间复杂度是 O(n)，其中 n 是数组的长度。
     *
     * 平均情况
     * 在平均情况下，假设输入数组是随机排列的，那么插入排序的时间复杂度是 O(n^2)。这是因为对于数组中的每个元素，算法可能需要与前面的多个元素进行比较，并可能需要多次移动元素来为新元素腾出位置。平均而言，每个元素需要与大约一半的前面元素进行比较，因此总的操作次数大约是 n * (n / 2)，简化后为 O(n^2)。
     *
     * 最坏情况
     * 在最坏的情况下，输入数组是逆序的，这意味着每一个新的元素都需要与前面所有的元素进行比较和移动才能找到其正确的位置。在这种情况下，对于第 i 个元素，它需要与前面的 i-1 个元素进行比较和移动，因此操作的总数为 1 + 2 + ... + (n-1)，这是一个等差数列求和问题，总和为 n*(n-1)/2，这同样简化为 O(n^2)。
     *
     * 空间复杂度
     * 插入排序的空间复杂度为 O(1)，因为它是一种原地排序算法，不需要额外的存储空间，除了几个临时变量之外，所有操作都在输入数组本身上进行。
     *
     * 总结来说，插入排序的时间复杂度在最佳情况下是 O(n)，在平均和最坏情况下是 O(n^2)。这使得插入排序在处理小数据集或部分已排序的数据集时非常有效，但在大数据集上效率较低。
     *
     * @param array 要排序的整数数组。
     */
    public static void insertionSort(int[] array) {
        // 从数组的第二个元素开始处理，因为我们将第一个元素视为已排序。
        for (int i = 1; i < array.length; i++) {
            // 当前要插入的值。
            int currentValue = array[i];

            // j 是当前要检查的已排序数组中的元素的索引。
            int j = i - 1;

            // 将大于当前值的所有已排序数组中的元素向右移动一位。
            while (j >= 0 && array[j] > currentValue) {
                // 将较大的元素向右移动。
                array[j + 1] = array[j];
                j--;  // 移动到左侧的下一个元素。
            }

            // 将当前值插入到正确的位置。
            array[j + 1] = currentValue;
        }
    }

    // 一个辅助方法，用于打印数组的内容。
    public static void printArray(int[] array) {
        for (int item : array) {
            System.out.print(item + " ");  // 打印数组中的每个元素。
        }
        System.out.println();  // 打印换行符，使输出更易读。
    }

    // 主方法，用于测试插入排序函数。
    public static void main(String[] args) {
        int[] unsortedArray = {9, 5, 1, 4, 3};

        System.out.println("原始数组：");
        printArray(unsortedArray);  // 打印未排序的数组。

        // 调用插入排序方法对数组进行排序。
        insertionSort(unsortedArray);

        System.out.println("排序后的数组：");
        printArray(unsortedArray);  // 打印排序后的数组。
    }
}
